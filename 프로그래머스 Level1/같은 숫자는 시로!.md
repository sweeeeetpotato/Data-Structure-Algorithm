<스택/큐 문제>

## 문제 설명
배열 arr가 주어집니다. 배열 arr의 각 원소는 숫자 0부터 9까지로 이루어져 있습니다. 이때, 배열 arr에서 연속적으로 나타나는 숫자는 하나만 남기고 전부 제거하려고 합니다. 단, 제거된 후 남은 수들을 반환할 때는 배열 arr의 원소들의 순서를 유지해야 합니다. 예를 들면,

* arr = [1, 1, 3, 3, 0, 1, 1] 이면 [1, 3, 0, 1] 을 return 합니다.
* arr = [4, 4, 4, 3, 3] 이면 [4, 3] 을 return 합니다.
배열 arr에서 연속적으로 나타나는 숫자는 제거하고 남은 수들을 return 하는 solution 함수를 완성해 주세요.

<br>

### 제한사항
* 배열 arr의 크기 : 1,000,000 이하의 자연수
* 배열 arr의 원소의 크기 : 0보다 크거나 같고 9보다 작거나 같은 정수

<br>

### 입출력 예
|arr|answer|
|:---:|:---:|
|[1,1,3,3,0,1,1]|[1,3,0,1]|
|[4,4,4,3,3]|[4,3]|

<br>

### 입출력 예 설명
입출력 예 #1,2
<br>
문제의 예시와 같습니다.

<br>

---

<br>

## 내 답안
<첫 풀이>
```JavaScript
function solution(arr){
    const answer = [];
    arr.map(num => {       
       answer[answer.length-1] !== num ? answer.push(num) : answer;
    })
    return answer;
}
```
> * 스택 사용. 스택의 top 부분 값과 새로 추가하려는 값이 같지 않을 경우에만 push.
> * map에서 index 인자를 사용할 수 있다는 사실을 잊고 있었음. 

<첫 풀이 리팩토링>
```JavaScript
function solution(arr){
    const answer = [];
    arr.map((num, index) => (num != arr[index-1]) && answer.push(num));
    return answer;
}
```
> * 스택 사용. 새로 추가하려는 값과 전의 값이 같지 않을 경우에만 push
> * map에서 index 인자를 사용하고, 삼항연산자 대신 &&연산자를 사용

<또 다른 풀이>
```JavaScript
function solution(arr){
    const answer = arr.filter((num, index) => num != arr[index+1]);
    return answer;
}
```
> * filter 메서드를 사용하여 현재 값과 다음 값이 일치하지 않는 경우만 추출. 즉 중복을 제거해줌.
> * 마지막 값을 비교할 때 arr[index+1]에서 배열의 length를 초과하게 되는데 이럴경우 값이 undefiend으로 나오기때문에 에러가 발생하지 않음.
